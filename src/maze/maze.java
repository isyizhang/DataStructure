package maze;

import java.util.Scanner;

/*思路：
 * 1、数组初始化迷宫
 * 2、设定走迷宫策略（下右上左）
 * 3、走不通的记为3，走得通的记为2
 * 4、    设置一个起始点，当目的地被标为2，即代表走通   
 * 
 *      7,1 //人大西门
		3,4 //明德楼
		8,15 //人文楼
		0,25 //北门
		5,23 //图书馆
		1,27 //邮局
		10,28 //东门
		2,23 //足球场

 * 5、递归
 * 按照韩的方法有bug，会陷入死循环，两个点来回跳。 如何避免走回路？ 
 * 需要增加判断条件
 * 
 * 
 * 
 */


public class maze {
	public static void main(String[] args) {
		
		int[][]maze = new int[][]{
			  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1},
			  {1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1},
			  {1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1},
			  {1,1,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1},
			  {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1},
			  {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},
			  {1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1},
			  {1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1},
			  {1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1},
			  {1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},
			  {1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
			  {1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
			  {1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1},
			  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
/*			  
		Scanner scan = new Scanner(System.in);
		System.out.println("请输入起始位置：（，）");
		int i = scan.nextInt();
		int j = scan.nextInt();
		System.out.println("请输入目的地：（，）");
		int a = scan.nextInt();
		int b = scan.nextInt();
*/		
		setWay(maze,7,1,7,2);
		for(int n=0;n<14;n++) {
			for(int m=0;m<30;m++) {
				System.out.print(maze[n][m]+" ");
			}
			System.out.println();
		}
		
	
	}


 static boolean setWay(int[][] map,int i,int j,int a,int b) {
	
	if(map[a][b] == 2) {
		return true;
		}else {
		if(map[i][j]==0) {
			map[i][j] = 2;
			
			if(setWay(map,i+1,j,a,b)) {
				return true;
			}else if(setWay(map,i,j+1,a,b)) {
				return true;
			}else if(setWay(map,i-1,j,a,b)) {
				return true;
			}else if(setWay(map,i,j-1,a,b)) {
				return true;
			}else {
				map[i][j]=3;
				return false;
			}	
		}
		else {
			return false;
		}
	}
 }	  
 
 
}











